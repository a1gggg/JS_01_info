<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Літерали та властивості</title>
  <h1>Літерали та властивості</h1>
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <button onclick="history.back()">ПОВЕРНУТИСЬ</button>


  
  <p>
    Створення пустого об'єкту без ідентифікатора та значення.:
  </p>
  <table>
    <tr>
      <td>
        <p2>
          1. let user = new Object();
        </p2>
      <br>  
        <p1>
          // синтаксис "конструктора об’єктів" 
        </p1>
      </td>
    </tr>
    <tr>
      <td> 
         <p2>
          2. let user = {};
         </p2>
        <br>  
          <p1>
            // синтаксис "літералу об’єкта"
          </p1>
      </td>
    </tr>
  </table>
 
  <p>
    Створення об'єкту за допомогою синтаксису літералу з ідентифікатором та значенням:
  </p>
  <table>
    <tr>
      <td>
        <p2>
          let user = { </br> &nbsp; &nbsp; &nbsp;name: "John", </br> &nbsp; &nbsp; &nbsp;age: 30</br> &nbsp; &nbsp;};
        </p2>
      <br>
        <p1>
          // об'єкт з ідентифікатором name та age та значеннями "John" та 30. В даному випадку "John" відноситься до рядків (string), а 30 до числа (number)
        </p1>
      </td>
    </tr>
  </table>

    <p>
      Додавання значення:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            object.key = value; 
          </p2>
        <br> 
          <p1>
           // object - назва об'єкта, key - назва ключа, value - значення;
          </br>
           // враховуючи попередній приклад, це може бути user.isAdmin = true;
          </p1>
        </br>
          <p2>
            object["key 1"] = value;  
          </p2>
        <br> 
          <p1>
           // синтаксис дозволяє будь які лапки [" "] або [' '] або [` `] та  використовується, якщо назва ключа містить пробіл або починається з цифри;
          </br>
           // в такому разі в обєкті це буде виглядати як "is Admin" = true, або 'is Admin' = true, або `is Admin` = true,
          </p1>
        </td>
      </tr>
    </table>

    <p>
      Виклик значення:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            object.key 
          </p2>
        <br> 
          <p1>
           // застосовується для виклику значення з об'єкта object {key = value,} - наприклад alert( user.isAdmin );
          </p1>
        </br>
          <p2>
            object["key 1"]
          </p2>
        <br> 
          <p1>
            // застосовується для виклику значення з об'єкта object {"key 1" = value,} - наприклад alert( user["is Admin] );
          </p1>
        </td>
      </tr>
    </table>

    <p>
      Видалення значення:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            delete object.key;
          </p2>
        <br> 
        <p1>
          // object - назва об'єкта, key - назва ключа, який потрібно видалити;
        <br>
        // враховуючи попередній приклад, це може бути delete user.isAdmin при якому видаляється ключ isAdmin з об'єкта user зі значенням true;
        </p1>
        <br> 
          <p2>
            delete object["key"];
          </p2>
        <br> 
          <p1>
        // враховуючи попередній приклад, це може бути delete user.["is Admin"] при якому видаляється ключ "is Admin" з об'єкта user зі значенням true;
          </p1>
          <p2>
        </td>
      </tr>
    </table>

    <p>
      Призначення змінній значення з ключа, який міститься в об'єкті:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            let key = "is Admin";
          </p2>
        <br> 
        <p1>
          // в такому разі не пов'язана з об'єктом змінна key отримує значення true з is Admin об'єкта user; Для виклику використовується синтаксис з застосуванням дужок [] </p1> <p2>user[key] = true;</p2>
          
        </td>
      </tr>
    </table>


    <p>
      Обчислення та отримання доступу до значення об'єкта за допомогою []:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            let user = {
            <br> &nbsp; &nbsp; &nbsp;
              name: "Іван",
            <br> &nbsp; &nbsp; &nbsp;
              age: 30
            <br> &nbsp; &nbsp; &nbsp;
            };
            <br><br>  &nbsp; &nbsp; &nbsp;
            let key = prompt("Що ви хочете знати про користувача?", "name");
            <br><br>  &nbsp; &nbsp; &nbsp;            
            alert( user[key] ); // Іван (якщо ввести "name")
          </p2>
        <br> 
        <p1>
          // Синтаксис з використанням квадратних дужок [] нам дозволяє передати значення, яке буде взяте змінною key з введенного в prompt. Наприклад, якщо в prompt введено name, воно передається змінній key, а при використанні синтаксису user[key] замість key обчислюється name і в результаті ми отримуємо  значення "Іван" з об'єкту user. Якщо в prompt ввести age, то в результаті отримаємо 30. 
        </p1>
          
        </td>
      </tr>
    </table>
 
    <p>
      Заміна ключа в об'єкті за допомогою квадратних дужок []:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            let fruit = prompt("Які фрукти купити?", "apple");
            <br> &nbsp; &nbsp; &nbsp;
            let bag = {
              <br> &nbsp; &nbsp; &nbsp;
              [fruit]: 5, // назву властивості взято зі змінної fruit
              <br> &nbsp; &nbsp; &nbsp;
         };
            <br><br> &nbsp; &nbsp; &nbsp;
            alert( bag.apple ); // 5 якщо fruit="apple"
            </p2>
            <br>
         <p1>
          // Синтаксис з використанням квадратних дужок [] навколо ключа в об'єкті (в даному випадку [fruit]) нам дозволяє передати значення, яке буде взяте змінною fruit з введенного в prompt. Наприклад, якщо в prompt введено apple, воно передається змінній fruit, і при використанні синтаксису bag.apple ми отримаємо значення 5. Якщо буде введено pear, то в результаті отримаємо undefined. Значення обчислюваної властивості просте: [fruit] означає, що назву властивості слід брати з fruit. І якщо відвідувач введе слово "apple", то в об’єкті bag тепер буде лежати властивість {apple: 5}.
        </p1>
        <br><br>
        <p1>**По суті, це працює так само як:</p1>
        <br>
        <p2>
          let fruit = prompt("Які фрукти купити?", "apple");
          <br> &nbsp; &nbsp; 
          let bag = {};
        </p2>
          <br>
          <p1> 
          // назву властивості взято зі змінної fruit
          <br> 
          </p1>
          <p2>
          bag[fruit] = 5;
          <br><br>
        </p2>
        <p1>**Випадки, якщо вираз складніший:</p1>
        <br>
        <p2>
          let fruit = 'apple';
          <br> &nbsp; &nbsp; 
let bag = {
  <br> &nbsp; &nbsp; 
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
  <br> &nbsp; &nbsp; 
};
<br> &nbsp; &nbsp; 
         </p2>
          <br>
          <p1> 
          // В даному випадку змінюється лише fruit на apple і в результаті ми отримаємо комбінований змінений ключ аppleComputers 
          <br> 
          </p1>
        </td>
      </tr>
    </table>

    <p>
      Скорочений запис властивості зі змінної (Property value shorthand):
    </p>
    <table>
      <tr>
        <td>
          <p2>
            function makeUser(name, age) {
            </br> &nbsp; &nbsp; &nbsp;
              return {
              </br> &nbsp; &nbsp; &nbsp;
                name: name,
              </br> &nbsp; &nbsp; &nbsp;
                age: age,
              </br> &nbsp; &nbsp; &nbsp;
                             };
            }
          </br> &nbsp; &nbsp; &nbsp;
            let user = makeUser("Іван", 30);
          </br> &nbsp; &nbsp; &nbsp;
            alert(user.name); // Іван
          </br> &nbsp; &nbsp; &nbsp;
          </p2>
        <br>
          <p1>
            //  Синтаксис name: name, та age: age, (повторення) допомогає нам скоротити запис, якщо назва ключа та змінної однакові та повертати й присвоювати значення, яке було отримано через ключ.
          </p1>
        </br> 
      </br> 
          <p1>
            **Це також можна записати як:
          </p1>
        </br> 
          <p2> 
          function makeUser(name, age) {
          </br> &nbsp; &nbsp; &nbsp;
            return {
            </br> &nbsp; &nbsp; &nbsp;
              name, // те ж саме, що name: name
            </br> &nbsp; &nbsp; &nbsp;
              age,  // те ж саме, що age: age
            </br> &nbsp; &nbsp; &nbsp;
             };
            </br> &nbsp; &nbsp; &nbsp;
          }
        </br> &nbsp; &nbsp; &nbsp;
        </p2>
      </br> 
      <p1>
        **Або комбінувати з звичайним записом:
      </p1>
    </br> 
      <p2> 
      function makeUser(name, age) {
      </br> &nbsp; &nbsp; &nbsp;
        return {
        </br> &nbsp; &nbsp; &nbsp;
          name, // або name: name
        </br> &nbsp; &nbsp; &nbsp;
        age: 30, // звичайний запис
        </br> &nbsp; &nbsp; &nbsp;
         };
        </br> &nbsp; &nbsp; &nbsp;
      }
    </br> &nbsp; &nbsp; &nbsp;
    </p2>
        </td>
      </tr>
    </table>
  

    <p>
      Обмеження для імен властивостей:
    </p>
    <table>
      <tr>
        <td>
        <br> 
        <p1>
          // Немає ніяких обмежень щодо назв властивостей. Це можуть бути будь-які рядки або символи (спеціальний тип для ідентифікаторів, про які буде сказано пізніше). нші типи автоматично перетворюються на рядки. Наприклад, число 0 стає рядком "0", коли використовується як ключ властивості.
          </p1>
          <br> <br> 
          <p1>**Особливості спеціальнї властивості __proto__</p1>
        <br>  
          <p2>
            let obj = {};
          </br> &nbsp; &nbsp;  
obj.__proto__ = 5; // присвоїмо число
          </br> &nbsp; &nbsp;  
alert(obj.__proto__); // [object Object] - значення є об’єктом, тобто не те, що ми очікували
          </br> 
          </p2>
          <p1> 
          //Як ми бачимо з коду, присвоєння числа 5 ігнорується. Причина чому це відбувається буде пояснена пізніше, але зараз ми можемо просто запам'ятати, що __proto__ - це особлива властивість, яка не може бути перезаписана.
        </p2>
        </td>
      </tr>
    </table>











    <br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;
    <br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;


  <br>
  <button onclick="history.back()">ПОВЕРНУТИСЬ</button>
  <script src="script_ObjectJS.js"></script>
  <div class="btn-up btn-up_hide"></div>

  <script>
    const btnUp = {
      el: document.querySelector('.btn-up'),
      show() {
        // удалим у кнопки класс btn-up_hide
        this.el.classList.remove('btn-up_hide');
      },
      hide() {
        // добавим к кнопке класс btn-up_hide
        this.el.classList.add('btn-up_hide');
      },
      addEventListener() {
        // при прокрутке содержимого страницы
        window.addEventListener('scroll', () => {
          // определяем величину прокрутки
          const scrollY = window.scrollY || document.documentElement.scrollTop;
          // если страница прокручена больше чем на 400px, то делаем кнопку видимой, иначе скрываем
          scrollY > 400 ? this.show() : this.hide();
        });
        // при нажатии на кнопку .btn-up
        document.querySelector('.btn-up').onclick = () => {
          // переместим в начало страницы
          window.scrollTo({
            top: 0,
            left: 0,
            behavior: 'smooth'
          });
        }
      }
    }
    btnUp.addEventListener();
    </script>
</body>
</html>