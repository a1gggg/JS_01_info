<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Об'єкти основи</title>
  <h1>Об'єкти основи</h1>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <button onclick="history.back()">ПОВЕРНУТИСЬ</button>
  <p>
    Створення пустого об'єкту без ідентифікатора та значення.:
  </p>
  <table>
    <tr>
      <td>
        <p2>
          1. let user = new Object();
        </p2>
      <br>
        <p1>
          // синтаксис "конструктора об’єктів" 
        </p1>
      </td>
    </tr> 
    <tr>
      <td> 
         <p2>
          2. let user = {};
         </p2>
        <br>  
          <p1>
            // синтаксис "літералу об’єкта"
          </p1>
      </td>
    </tr>
  </table>
 
  <p>
    Створення об'єкту за допомогою синтаксису літералу з ідентифікатором та значенням:
  </p>
  <table>
    <tr>
      <td>
        <p2>
          let user = { </br> &nbsp; &nbsp; &nbsp;name: "John", </br> &nbsp; &nbsp; &nbsp;age: 30</br> &nbsp; &nbsp;};
        </p2>
      <br>
        <p1>
          // об'єкт з ідентифікатором name та age та значеннями "John" та 30. В даному випадку "John" відноситься до рядків (string), а 30 до числа (number)
        </p1>
      </td>
    </tr>
  </table>

  <p>
      Додавання значення:
  </p>
    <table>
      <tr>
        <td>
          <p2>
            object.key = value; 
          </p2>
        <br> 
          <p1>
           // object - назва об'єкта, key - назва ключа, value - значення;
          </br>
           // враховуючи попередній приклад, це може бути user.isAdmin = true;
          </p1>
        </br>
          <p2>
            object["key 1"] = value;  
          </p2>
        <br> 
          <p1>
           // синтаксис дозволяє будь які лапки [" "] або [' '] або [` `] та  використовується, якщо назва ключа містить пробіл або починається з цифри;
          </br>
           // в такому разі в обєкті це буде виглядати як "is Admin" = true, або 'is Admin' = true, або `is Admin` = true,
          </p1>
        </td>
      </tr>
    </table>

    <p>
      Виклик значення:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            object.key 
          </p2>
        <br> 
          <p1>
           // застосовується для виклику значення з об'єкта object {key = value,} - наприклад alert( user.isAdmin );
          </p1>
        </br>
          <p2>
            object["key 1"]
          </p2>
        <br> 
          <p1>
            // застосовується для виклику значення з об'єкта object {"key 1" = value,} - наприклад alert( user["is Admin] );
          </p1>
        </td>
      </tr>
    </table>

    <p>
      Видалення значення:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            delete object.key;
          </p2>
        <br> 
        <p1>
          // object - назва об'єкта, key - назва ключа, який потрібно видалити;
        <br>
        // враховуючи попередній приклад, це може бути delete user.isAdmin при якому видаляється ключ isAdmin з об'єкта user зі значенням true;
        </p1>
        <br> 
          <p2>
            delete object["key"];
          </p2>
        <br> 
          <p1>
        // враховуючи попередній приклад, це може бути delete user.["is Admin"] при якому видаляється ключ "is Admin" з об'єкта user зі значенням true;
          </p1>
          <p2>
        </td>
      </tr>
    </table>

    <p>
      Призначення змінній значення з ключа, який міститься в об'єкті:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            let key = "is Admin";
          </p2>
        <br> 
        <p1>
          // в такому разі не пов'язана з об'єктом змінна key отримує значення true з is Admin об'єкта user; Для виклику використовується синтаксис з застосуванням дужок [] </p1> <p2>user[key] = true;</p2>
          
        </td>
      </tr>
    </table>


    <p>
      Обчислення та отримання доступу до значення об'єкта за допомогою []:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            let user = {
            <br> &nbsp; &nbsp; &nbsp;
              name: "Іван",
            <br> &nbsp; &nbsp; &nbsp;
              age: 30
            <br> &nbsp; &nbsp; &nbsp;
            };
            <br><br>  &nbsp; &nbsp; &nbsp;
            let key = prompt("Що ви хочете знати про користувача?", "name");
            <br><br>  &nbsp; &nbsp; &nbsp;            
            alert( user[key] ); // Іван (якщо ввести "name")
          </p2>
        <br> 
        <p1>
          // Синтаксис з використанням квадратних дужок [] нам дозволяє передати значення, яке буде взяте змінною key з введенного в prompt. Наприклад, якщо в prompt введено name, воно передається змінній key, а при використанні синтаксису user[key] замість key обчислюється name і в результаті ми отримуємо  значення "Іван" з об'єкту user. Якщо в prompt ввести age, то в результаті отримаємо 30. 
        </p1>
          
        </td>
      </tr>
    </table>
 
    <p>
      Заміна ключа в об'єкті за допомогою квадратних дужок []:
    </p>
    <table>
      <tr>
        <td>
          <p2>
            let fruit = prompt("Які фрукти купити?", "apple");
            <br><br> &nbsp; &nbsp;  
            let bag = {
              <br> &nbsp; &nbsp; &nbsp; 
              [fruit]: 5, // назву властивості взято зі змінної fruit
              <br> &nbsp; &nbsp;  
         };
            <br><br> &nbsp; &nbsp;  
            alert( bag.apple ); // 5 якщо fruit="apple"
            </p2>
            <br>
         <p1>
          // Синтаксис з використанням квадратних дужок [] навколо ключа в об'єкті (в даному випадку [fruit]) нам дозволяє передати значення, яке буде взяте змінною fruit з введенного в prompt. Наприклад, якщо в prompt введено apple, воно передається змінній fruit, і при використанні синтаксису bag.apple ми отримаємо значення 5. Якщо буде введено pear, то в результаті отримаємо undefined. Значення обчислюваної властивості просте: [fruit] означає, що назву властивості слід брати з fruit. І якщо відвідувач введе слово "apple", то в об’єкті bag тепер буде лежати властивість {apple: 5}.
        </p1>
        <br><br>
        <p1>**По суті, це працює так само як:</p1>
        <br>
        <p2>
          let fruit = prompt("Які фрукти купити?", "apple");
          <br> &nbsp; &nbsp; 
          let bag = {};
        </p2>
          <br>
          <p1> 
          // назву властивості взято зі змінної fruit
          <br> 
          </p1>
          <p2>
          bag[fruit] = 5;
          <br><br>
        </p2>
        <p1>**Випадки, якщо вираз складніший:</p1>
        <br>
        <p2>
          let fruit = 'apple';
          <br><br>  &nbsp; &nbsp; 
let bag = {
  <br> &nbsp; &nbsp; &nbsp; 
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
  <br> &nbsp; &nbsp; 
};
<br> &nbsp; &nbsp; 
         </p2>
          <br>
          <p1> 
          // В даному випадку змінюється лише fruit на apple і в результаті ми отримаємо комбінований змінений ключ аppleComputers 
          <br> 
          </p1>
        </td>
      </tr>
    </table>

    <p>
      Скорочений запис властивості зі змінної (Property value shorthand):
    </p>
    <table>
      <tr>
        <td>
          <p2>
            function makeUser(name, age) {
            </br> &nbsp; &nbsp; &nbsp; 
              return {
              </br> &nbsp; &nbsp; &nbsp; &nbsp;
                name: name,
              </br> &nbsp; &nbsp; &nbsp; &nbsp;
                age: age,
              </br> &nbsp; &nbsp; &nbsp;
                             };
              </br> &nbsp; &nbsp;
            }
          </br></br>  &nbsp; &nbsp; &nbsp;
            let user = makeUser("Іван", 30);
          </br> </br> &nbsp; &nbsp; &nbsp;
            alert(user.name); // Іван
          </br> &nbsp; &nbsp; &nbsp;
          </p2>
        <br>
          <p1>
            //  Синтаксис name: name, та age: age, (повторення) допомогає нам скоротити запис, якщо назва ключа та змінної однакові та повертати й присвоювати значення, яке було отримано через ключ.
          </p1>
        </br> 
      </br> 
          <p1>
            **Це також можна записати як:
          </p1>
        </br> 
          <p2> 
          function makeUser(name, age) {
          </br> &nbsp; &nbsp; &nbsp; &nbsp;
            return {
            </br> &nbsp; &nbsp; &nbsp; &nbsp;
              name, // те ж саме, що name: name
            </br> &nbsp; &nbsp; &nbsp; &nbsp;
              age,  // те ж саме, що age: age
            </br> &nbsp; &nbsp; &nbsp;  
             };
            </br> &nbsp; &nbsp;  
          }
        </br> &nbsp; &nbsp; &nbsp;
        </p2>
      </br> 
      <p1>
        **Або комбінувати з звичайним записом:
      </p1>
    </br> 
      <p2> 
      function makeUser(name, age) {
      </br> &nbsp; &nbsp; &nbsp;
        return {
        </br> &nbsp; &nbsp; &nbsp; &nbsp;
          name, // або name: name
        </br> &nbsp; &nbsp; &nbsp; &nbsp;
        age: 30, // звичайний запис
        </br> &nbsp; &nbsp; &nbsp;  
         };
        </br>   &nbsp; &nbsp;
      }
    </br> &nbsp; &nbsp; &nbsp;
    </p2>
        </td>
      </tr>
    </table>
  

    <p>
      Обмеження для імен властивостей:
    </p>
    <table>
      <tr>
        <td>
        <br> 
        <p1>
          // Немає ніяких обмежень щодо назв властивостей. Це можуть бути будь-які рядки або символи (спеціальний тип для ідентифікаторів, про які буде сказано пізніше). нші типи автоматично перетворюються на рядки. Наприклад, число 0 стає рядком "0", коли використовується як ключ властивості.
          </p1>
          <br> <br> 
          <p1>**Особливості спеціальнї властивості __proto__</p1>
        <br>  
          <p2>
            let obj = {};
          </br> &nbsp; &nbsp;  
obj.__proto__ = 5; // присвоїмо число
          </br> &nbsp; &nbsp;  
alert(obj.__proto__); // [object Object] - значення є об’єктом, тобто не те, що ми очікували
          </br> 
          </p2>
          <p1> 
          //Як ми бачимо з коду, присвоєння числа 5 ігнорується. Причина чому це відбувається буде пояснена пізніше, але зараз ми можемо просто запам'ятати, що __proto__ - це особлива властивість, яка не може бути перезаписана.
        </p2>
        </td>
      </tr>
    </table>
  </br>
    
    <p>
      Перевірка існування властивості:
    </p>
    <table>
      <tr>
        <td>
          <p1>
          1. Задопомогою оператора in ("key" in object) з лапками для ключа та (key in object) без лапок для змінної, яка містить ключ:
          </p1>
        <br>
           <p2>
          let user = { 
        </br> &nbsp; &nbsp; &nbsp; 
          name: "Іван", //значення,
        </br> &nbsp; &nbsp; &nbsp; 
          age: 30, //число,
        </br> &nbsp; &nbsp; &nbsp; 
          isAdmin: undefined, //undefined,
        </br> &nbsp; &nbsp; &nbsp; 
        tel: null, //null
      </br> &nbsp; &nbsp; 
        };
        </br></br> &nbsp; &nbsp; 
          alert( "age" in user ); // отримано true, ключ user.age існує
      </br> &nbsp; &nbsp; 
          alert( "blabla" in user ); // отримано false,  ключ user.blabla не існує
      </br>
        </p2>
        <br><br> 
        <p1> 
          // ключі, які було створено та призначено властивіть також будуть повертати true при перевірці на існування, навіть якщо їм було присвоєно значення undefined або null.
      </p1>
      <br><br> 
           <p2>
            let user = { age: 30 };
          </br> &nbsp; &nbsp; 
            let key = "age"; //присвоєння змінній key значення age з об'єкта user
          </br> </br> &nbsp; &nbsp; 
            alert( key in user ); // true, змінній key присвоєна властивість "age" з об'єкта user
 
      </br></br></br>
        </p2>
        </br> </br>
        <p1> 
         2. Порівняння з undefined (key === undefined):
        </p1>
      </br> 
        <p2>
          let user = {};// створено пустий об'єкт
        </br> 
        </p2>
        <p1> </br> &nbsp; &nbsp; &nbsp;&nbsp;
          або
        </p1>
      </br> 
        <p2>
        let user = {
       </br> &nbsp; &nbsp;&nbsp; 
        noSuchProperty: undefined,  // створено  об'єкт з ключом, якому присвоєно значення undefined;
       </br> &nbsp; &nbsp; 
        };
      </br> &nbsp; &nbsp; 
      </br> &nbsp; &nbsp; 
alert( user.noSuchProperty === undefined ); // повертає значення true в обох випадках
</br> 
</p2>
<p1> 
// значення true означає, що такої властивості немає або noSuchProperty призначено значення undefined (noSuchProperty: undefined, ). Якщо значення існує та не дорівнює undefined, то повертається false.
        </br> 
        </p1>
        </td>
      </tr>
    </table>

    
<p>
  Цикл "for..in" для перебору ключів об'єкта ( for (key in object) {
    object( key ); alert( object[key] );   } ) :
</p>
<table>
  <tr>
    <td>
      <p1> 
        Створення об'єкту:
      </p1>
       <br>
      <p2>
        let user = {
        </br> &nbsp; &nbsp; &nbsp; 
          name: "Іван",
        </br> &nbsp; &nbsp; &nbsp; 
          age: 30,
        </br> &nbsp; &nbsp; &nbsp; 
          isAdmin: true
        </br> &nbsp; &nbsp; 
        };
        </br></br> &nbsp; &nbsp; 
      </p2> 
      </br>
      <p1> 
          Запуск циклу:
      </p1>
      </br>
      <p2>
        for (let key in user) {
        </br> &nbsp; &nbsp;  &nbsp; 
          alert( key );  // отримуємо ключі - name, age, isAdmin
        </br> &nbsp; &nbsp;  &nbsp; 
          alert( user[key] ); // отримуємо значення ключів - Іван, 30, true
        </br> &nbsp; &nbsp; 
        }
      
    </br> 
    </p2>
    <p1> 
//  let key - змінна, яка буде містити ключі об'єкта user. В циклі for..in змінна key буде приймати значення кожного з ключів об'єкта user по черзі. В результаті alert( key ) виведе на екран всі ключі об'єкта user, а alert( user[key] ) - їх значення.
    </br> 
    </p1>
    </td>
  </tr>
</table>

<p>
  Впорядкування та сортування ключів властивостей в об’єкті:
</p>
<table>
  <tr>
    <td>
      <p1> 
        Стандартне впорядкування вібувається наступним чином:
      </br> &nbsp; &nbsp; 
      1. Цілочисельні ключі (5 : ..., 70 : ..., 33 : ..., 40 : ..., 51 : ..., 100 : ...,) сортуються за зростанням (5 : ..., 33 : ..., 40 : ..., 51 : ..., 70 : ..., 100 : ...,).
    </br> &nbsp; &nbsp; 
      2. Не цілочисельні ключі, рядки та інші сортуються в порядку створення.
    </br> &nbsp; &nbsp; 
      3. Ключі, які починаються з символу "0" (наприклад "0abc", "0def", "0ghi") сортуються в порядку створення.
      <br><br>
      Перетворення на цілочисельний ключ:
      <br>
      // Number(...) -- явно перетворює на число
      <br>
      // Math.trunc -- вбудована функція, яка видаляє десяткову частину
      </p1>
       <br><br>
       <p2>
alert( String( Math.trunc( Number("49"))) ); // отримано "49", після перетворення з "49"
</br> &nbsp; &nbsp; 
alert( String( Math.trunc( Number("+49"))) ); // отримано "49", після перетворення з "+49" 
</br> &nbsp; &nbsp; 
alert( String( Math.trunc( Number("1.2")))); // отримано "1", після перетворення з "1.2"  
      </p2> 
      <br>
     </td>
  </tr>
</table>

<p>
  Висновок:
</p>
<table>
  <tr>
    <td>
      <p1> 
        Об’єкти – це асоціативні масиви з рядом додаткових можливостей.
      </br></br>  
        Вони зберігають властивості (пари ключ-значення), де:
      </br>      
        * Ключі властивостей повинні бути рядками або символами (зазвичай рядками).
      </br> 
        * Значення можуть бути будь-якого типу.
      </br> </br> 
        Щоб отримати доступ до властивості, ми можемо використовувати:
      </br> 
        * Запис через крапку: obj.property.
      </br> 
        * Квадратні дужки obj["property"]. Квадратні дужки дозволяють взяти ключ зі змінної, наприклад, obj[varWithKey].
      </br> </br> 
        Додаткові оператори:
      </br> 
        * Видалення властивості: delete obj.prop.
      </br> 
        * Перевірка існування властивості: "key" in obj.
      </br> 
        * Перебір властивостей об’єкта: цикл for (let key in obj).
      </br> </br> 
        Те, що ми вивчали в цьому розділі, називається “простим об’єктом” або просто Object.
      </br> </br> 
        В JavaScript є багато інших типів об’єктів:
      </br> 
        * Array для зберігання впорядкованих колекцій даних,
      </br> 
        * Date для зберігання інформації про дату і час,
      </br> 
        * Error для зберігання інформації про помилку.
      </br> 
        * … і так далі.
      </br> </br> 
        У них є свої особливості, які ми вивчимо пізніше. Іноді люди говорять щось на кшталт “тип даних Array” або “тип даних Date”, але формально вони не є окремими типами, а належать до типу даних "Object". Вони лише розширюють його різними способами.
      </br> </br> 
        Об’єкти в JavaScript дуже потужні. Тут ми тільки трохи заглибилися в дійсно величезну тему. Ми будемо тісно працювати з об’єктами та дізнаємося про них більше в наступних частинах посібника.
    <br> 
        </p1>
    <br>
     </td>
  </tr>
</table>


<p>
  Тест на перевірку наявності ключів в об'єкті:
</p>
<table>
  <tr>
    <td>
      <p1> 
        Цикл по ключам об'єкта:
      </br> &nbsp; &nbsp; 
        * якщо є хоч один ключ  - повертає false
      </br> &nbsp; &nbsp; 
        * якщо ключі відсутні - повертає true
      </br> 
      </p1>

      <p2>
      
function isEmpty(obj) {
</br> &nbsp; &nbsp; 
    for (let key in obj) {
  </br> &nbsp; &nbsp;  &nbsp;
    return false;
  </br> &nbsp; &nbsp; &nbsp;
  }
</br> &nbsp; &nbsp; 
    return true;
</br> &nbsp; 
}
      </p2>
      </td>
      </tr> 
      </table>

 

*****
Підсумувати значення об'єкта:
let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}

function sumSalaries(salaries) {
  let sum = 0;
  for (let key in salaries) {
    sum += salaries[key];
  }
  return sum;
}

alert (sumSalaries(salaries)); 
******







  <br>
  <button onclick="history.back()">ПОВЕРНУТИСЬ</button>

  <script src="script_ObjectJS.js"></script>
  <div class="btn-up btn-up_hide"></div>

  <script>
    const btnUp = {
      el: document.querySelector('.btn-up'),
      show() {
        // удалим у кнопки класс btn-up_hide
        this.el.classList.remove('btn-up_hide');
      },
      hide() {
        // добавим к кнопке класс btn-up_hide
        this.el.classList.add('btn-up_hide');
      },
      addEventListener() {
        // при прокрутке содержимого страницы
        window.addEventListener('scroll', () => {
          // определяем величину прокрутки
          const scrollY = window.scrollY || document.documentElement.scrollTop;
          // если страница прокручена больше чем на 400px, то делаем кнопку видимой, иначе скрываем
          scrollY > 400 ? this.show() : this.hide();
        });
        // при нажатии на кнопку .btn-up
        document.querySelector('.btn-up').onclick = () => {
          // переместим в начало страницы
          window.scrollTo({
            top: 0,
            left: 0,
            behavior: 'smooth'
          });
        }
      }
    }
    btnUp.addEventListener();
    </script>
</body>
</html>