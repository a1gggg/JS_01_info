<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Оператори порівняння</title>
  <h1>Оператори порівняння</h1>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <button onclick="history.back()">ПОВЕРНУТИСЬ</button>
<p>
Оператори:</br>
&nbsp;Більше/менше: a > b, a < b.</br></b.>
&nbsp;Більше/менше або дорівнює: a >= b, a <= b.</br>
&nbsp;Дорівнює: a == b. Зверніть увагу, для порівняння потрібно використовувати два знаки рівності ==. Один знак рівності a = b означав би присвоєння.</br>
&nbsp;Не дорівнює:   a != b.</br></br>
Результатам порівняння буде true або false.</br>
Приклади----------------</br>
&nbsp;&nbsp;( 2 > 1 );  // true </br>
&nbsp;&nbsp;( 2 == 1 ); // false </br>
&nbsp;&nbsp;( 2 != 1 ); // true</br>
------------------------</br></br>
Результат порівняння можна присвоїти змінній, як і будь-яке інше значення:</br>
Приклади----------------</br>
&nbsp;&nbsp;let result = 5 > 4; // присвоїти результат порівняння змінній result</br>
&nbsp;&nbsp;alert( result ); // true</br>
------------------------</br></br></br>
Порівняння рядків</br>
Для порівняння рядків застосовується лексичний (посимвольний порядок) та кодування Unicode, а не справжній алфавіт:</br>
Приклади----------------</br>
&nbsp;&nbsp;( 'Я' > 'А' ); // true</br>
&nbsp;&nbsp;( 'Соки' > 'Сода' ); // true</br>
&nbsp;&nbsp;( 'Комар' > 'Кома' ); // true</br>
------------------------</br>
&nbsp;1 Порівнюються перші символи обох рядків.</br>
&nbsp;2 Якщо перший символ першого рядка більший (менший) за перший символ другого рядка, то перший рядок більший (менший) за другий. Порівняння закінчено.</br>
&nbsp;3 В іншому випадку, якщо перші символи обох рядків рівні, то таким самим чином порівнюються вже другі символи рядків.</br>
&nbsp;4 Порівняння продовжується до того часу, доки не закінчиться один з рядків.</br>
&nbsp;5 Якщо два рядки закінчуються одночасно, то вони рівні. Інакше, довший рядок вважатиметься більшим.</br>
&nbsp;В прикладах вище, порівняння 'Я' > 'А' завершиться на першому кроці.</br>
Проте друге порівняння слів 'Соки' і 'Сода' буде виконуватися посимвольно:</br></br>
&nbsp;1 С дорівнює С.</br>
&nbsp;2 о дорівнює о.</br>
&nbsp;3 к більше ніж д. На цьому кроці порівнювання закінчується. Перший рядок більший.</br>
В кодуванні Unicode має значення регістр символів. Велика буква "А" не рівна маленькій "а". Але яка з них більше? Маленька буква "а". Чому? Тому що маленькі букви мають більший код у внутрішній таблиці кодування, яку використовує JavaScript (Unicode). </br></br></br>
Порівняння різних типів</br>
При порівнянні різних типів значення перетворюються в числа:</br>
&nbsp;&nbsp;( '2' > 1 ); // true, рядок '2' стає числом 2</br>
&nbsp;&nbsp;( '01' == 1 ); // true, рядок '01' стає числом 1</br>
&nbsp;&nbsp;( true == 1 ); // true - true стає 1</br>
&nbsp;&nbsp;( false == 0 ); // true - false стає 0.</br></br>
Boolean перетворення 0:</br>
&nbsp;let a = 0; alert( Boolean(a) ); // false. 0 число перетворюється в false.</br>
&nbsp;let b = "0"; alert( Boolean(b) ); // true. 0 типу string перетворюється в true.</br>
&nbsp;alert(a == b); // true! але при не строгому порівнянні. 0 рядок перетворюється в число і починає дорівнювати числу 0 </br></br></br>
Строге порівняння:</br>
Використання звичайного оператора порівняння == може викликати проблеми:</br>
&nbsp;( 0 == false ); // true - він не відрізняє 0 від false;</br>
&nbsp;( '' == false ); // true - пустий рядок також перетворюється на;</br>
Це відбувається тому, що операнди різних типів перетворюються оператором порівняння == на числа. Пустий рядок, так само як false, стане нулем.</br></br>
Оператор строгої рівності === перевіряє рівність без перетворення типів.</br>
&nbsp;( 0 === false ); // false, тому що порівнюються різні типи</br>
&nbsp;( 0 == false ); // true, тому що false перетворюється на 0</br>
Є також оператор строгої нерівності !==, аналогічний до !=.</br></br></br>
Порівняння з null і undefined</br>
Поведінка null і undefined під час порівняння з іншими значеннями — особливе:</br>
1. При строгому порівнянні ===</br>
&nbsp;Ці значення різні, тому що різні їхні типи.</br>
&nbsp;( null === undefined ); // false</br></br>
При нестрогому порівнянні ==</br>
&nbsp;Ці значення рівні. Водночас ці значення не рівні значенням інших типів. Це спеціальне правило мови.</br>
&nbsp;( null == undefined ); // true</br></br>
Під час використання математичних операторів та інших операторів порівняння < > <= >=</br>
Значення null/undefined конвертуються в числа: null стає 0, тоді як undefined стає NaN.</br></br>
Тепер глянемо, які кумедні речі трапляються, коли ми застосовуємо ці правила. І, що більш важливо, як уникнути помилок під час їхнього використання.</br>
Дивний результат порівняння null і 0</br>
Порівняємо null з нулем:</br>
&nbsp;( null > 0 );  // (1) false</br>
&nbsp;( null == 0 ); // (2) false</br>
&nbsp;( null >= 0 ); // (3) true</br>
З погляду математики це дивно. Результат останнього порівняння показує, що “null більше або дорівнює нулю”, в такому випадку результат одного з порівнянь вище повинен бути true, але вони обидва false.</br>
Причина в тому, що нестроге порівняння == і порівняння > < >= <= працюють по-різному. Останні оператори конвертують null в число, розглядаючи його як 0. Ось чому вираз (3) null >= 0 дає true, а вираз (1) null > 0 — false.</br>
З іншого боку, для нестрогого порівняння == значень undefined і null діє окреме правило: ці значення не перетворюються на інші типи, вони рівні один одному і не рівні будь-чому іншому. Ось чому вираз (2) null == 0 повертає результат false.</br></br>
Не порівнюйте значення undefined</br>
Значення undefined не має порівнюватись з іншими значеннями:</br>
&nbsp;( undefined > 0 ); // false (1)</br>
&nbsp;( undefined < 0 ); // false (2)</br>
&nbsp;( undefined == 0 ); // false (3)</br></br>
Чому тоді порівняння undefined з нулем завжди повертає false?</br>
Ми отримуємо такі результати, тому що:</br>
&nbsp;Порівняння (1) і (2) повертає false, тому що undefined під час порівняння з “не null” значеннями завжди конвертується в NaN, а NaN — це спеціальне числове значення, яке завжди повертає false під час будь-яких порівнянь.</br>
&nbsp;Нестроге порівняння (3) повертає false, тому що undefined рівне тільки null, undefined і жодним іншим значенням.</br></br>
Як уникати проблем</br>
Чому ми переглядали ці приклади? Чи повинні ми постійно пам'ятати про всі ці особливості? Не обов'язково. З часом всі ці заплутані правила стануть для вас знайомими, але можна уникнути проблем, якщо дотримуватися надійних правил:
Будьте пильні під час порівняння будь-якого значення з undefined/null, за винятком строгого порівняння ===.</br>
Не використовуйте порівняння >= > < <= зі змінними, які можуть приймати значення null/undefined, хіба що ви цілком впевнені в тому, що робите. Якщо змінна може приймати ці значення, то додайте для них окремі перевірки.</br>

Підсумки:</br></br>
&nbsp;Оператори порівняння повертають значення логічного типу.</br>
&nbsp;Рядки порівнюються посимвольно в лексикографічному порядку.</br>
&nbsp;Значення різних типів під час порівняння конвертуються в числа. Винятками є порівняння за допомогою операторів строгої рівності/нерівності.</br>
&nbsp;Значення null і undefined рівні == один одному і не рівні будь-якому іншому значенню.</br>
&nbsp;Будьте обережні, використовуючи оператори порівняння на зразок > чи < зі змінними, які можуть приймати значення null/undefined. Хорошою ідеєю буде зробити окрему перевірку на null/undefined для таких значень. Порівняння з null і undefined</br>

Приклади----------------</br>
&nbsp;5 > 4 → true // Очевидно, 5 більше за 4. true.</br>
&nbsp;"ананас" > "яблуко" → false // Посимвольне порівняння, тому false. "а" менше за "я".</br>
&nbsp;"2" > "12" → true // Знову посимвольне порівняння. Перший символ рядка "2" більший за перший символ другого рядка — "1".</br>
&nbsp;undefined == null → true // Спеціальний випадок. Значення null і undefined рівні лише один одному під час нестрогого порівняння.</br>
&nbsp;undefined === null → false // Строге порівняння різних типів, тому false.</br>
&nbsp;null == "\n0\n" → false // Аналогічно, як в кроці (4), null дорівнює лише undefined.</br>
&nbsp;null === +"\n0\n" → false // Строге порівняння різних типів.</br>
------------------------</br>

</p>
</br> &nbsp; &nbsp; &nbsp;


  <br>
  <button onclick="history.back()">ПОВЕРНУТИСЬ</button>

  <script src="script_ObjectJS.js"></script>
  <div class="btn-up btn-up_hide"></div>

  <script>
    const btnUp = {
      el: document.querySelector('.btn-up'),
      show() {
        // видалимо клас btn-up_hide
        this.el.classList.remove('btn-up_hide');
      },
      hide() {
        // добавимо до кнопки клас btn-up_hide
        this.el.classList.add('btn-up_hide');
      },
      addEventListener() {
        // при прокрутка змісту сторінки
        window.addEventListener('scroll', () => {
          // встановлюємо величину прокрутки
          const scrollY = window.scrollY || document.documentElement.scrollTop;
          // якщо сторінка прокручена більша чим на 400px, то робимо кнопку видимою, або приховуємо
          scrollY > 400 ? this.show() : this.hide();
        });
        // при натисканні на кнопку .btn-up
        document.querySelector('.btn-up').onclick = () => {
          // переміщаємо на початок сторінки
          window.scrollTo({
            top: 0,
            left: 0,
            behavior: 'smooth'
          });
        }
      }
    }
    btnUp.addEventListener();
    </script>
</body>
</html>