<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Оператор об’єднання з null '??'</title>
  <h1>Оператор об’єднання з null '??'</h1>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <button onclick="history.back()">ПОВЕРНУТИСЬ</button>



<p>
Оператор об’єднання з null '??'</br></br>
У старих браузерах може бути потрібен поліфіл.</br>
Записується як два знаки питання ??.</br>
</br>
Оскільки null і undefined сприймаються однаково, ми введемо спеціальну домовленість. В цій статті ми будемо вважати, що значення виразу “визначене”, якщо воно відрізняється від null та undefined.</br>
</br>
Результатом a ?? b буде:</br>
</br>
a, якщо a визначене,</br>
b, якщо a не визначене.</br></br>
Інакше кажучи, ?? повертає перший аргумент, якщо він не null/undefined. Інакше, другий.</br></br>
</br>
Оператор об’єднання з null не є абсолютно новим. Це просто хороший синтаксис, щоб отримати перше “визначене” значення з двох.</br>
</br>
Ми можемо переписати вираз result = a ?? b, використовуючи оператори, які ми вже знаємо:</br>
</br>
result = (a !== null && a !== undefined) ? a : b;</br>
Тепер повинно бути абсолютно зрозуміло, що робить ??. Подивімось, де це допомагає.</br>
</br>
Наприклад, тут ми показуємо значення у змінній user, якщо її значення не null/undefined, інакше – показуємо Анонімний:</br>
</br>
Ось приклад з user, якому не присвоєне ім’я:</br>
</br>
let user;</br>
</br>
alert(user ?? "Анонімний"); // Анонімний (user є undefined)</br>
Ми також можемо використовувати послідовність з ??, щоб вибрати перше значення зі списку, яке не є null/undefined.</br>
</br>
Скажімо, у нас є дані користувача в змінних firstName, lastName або nickName. Всі вони можуть бути не визначені, якщо користувач вирішив не вводити значення.</br>
</br>
Ми хотіли б показати ім’я користувача, використовуючи одну з цих змінних, або показати “Анонімний”, якщо всі вони null/undefined.
</br>
Використаймо оператор ?? для цього:</br>
</br>
let firstName = null;</br>
let lastName = null;</br>
let nickName = "Суперкодер";</br>
</br>
// показує перше визначене значення:</br>
alert(firstName ?? lastName ?? nickName ?? "Анонімний"); // Суперкодер</br>
Порівняння з ||</br>
Оператор АБО || може бути використаний таким же чином, як ??, як це було описано в попередній главі.</br>
</br>
Наприклад, у коді вище, ми могли б замінити ?? на || і все ще отримали б той самий результат:</br>
</br>
let firstName = null;</br>
let lastName = null;</br>
let nickName = "Суперкодер";</br>
</br>
// показує перше істинне значення:</br>
alert(firstName || lastName || nickName || "Анонімний"); // Суперкодер</br>
Історично, оператор АБО || був першим. Він існує з початку JavaScript, тому розробники використовували його для цих цілей протягом тривалого часу.</br>
</br>
З іншого боку, оператор об’єднання з null ?? було нещодавно додано в JavaScript, і причиною того було те, що люди були не дуже задоволені ||.</br>
</br>
Важлива різниця між ними полягає в тому, що:</br>
</br></br>
|| повертає перше істинне значення.</br>
?? повертає перше визначене значення.</br>
Інакше кажучи, оператор || не розрізняє, чи значення false, 0, порожній рядок "" чи null/undefined. Всі вони однакові – хибні значення. Якщо будь-яке з них є першим аргументом ||, тоді ми отримаємо другий аргумент як результат.</br>
</br>
Однак на практиці, ми хочемо використовувати типове значення лише тоді, коли змінна null/undefined. Тобто, коли значення дійсно невідоме/не встановлене.</br>
</br>
Наприклад, розгляньте це:</br>
</br>
let height = 0;</br>
</br>
alert(height || 100); // 100</br>
alert(height ?? 100); // 0</br>
height || 100 перевіряє чи має змінна height має хибне значення, і 0 – це дійсно хибне значення.</br>
отже, результатом || є другий аргумент, 100.</br>
height ?? 100 перевіряє змінну height, чи вона null/undefined, і це не так,</br>
отже, результат – height “як є”, тобто 0.</br>
На практиці нульова висота часто є дійсним значенням, яке не слід замінювати на типове значення. Отже, ?? робить саме те, що треба.</br>
</br>
Пріоритет</br>
Пріоритет оператора ?? такий самий, як у ||. Він дорівнює 3 у таблиці MDN.</br>
</br>
Це означає, що, як і ||, оператор об’єднання з null ?? оцінюється до = та ?, але після більшості інших операцій, таких як +, *.</br>
</br>
let height = null;</br>
let width = null;</br>
</br>
// важливо: використовуйте дужки</br>
let area = (height ?? 100) * (width ?? 50);</br>
</br>
alert(area); // 5000</br>
В іншому випадку, якщо ми опускаємо дужки, то, оскільки * має вищий пріоритет, ніж ??, то він буде виконуватися першим, що призводить до неправильних результатів.</br>
</br>
// без дужок</br>
let area = height ?? 100 * width ?? 50;</br>
</br>
// ...працює так само, як попередній вираз (мабуть, це не те, що ми хочемо):</br>
let area = height ?? (100 * width) ?? 50;</br></br>
Використання ?? разом з && або ||</br>
З міркувань безпеки, JavaScript забороняє використання ?? разом з операторами && та ||, якщо пріоритет явно не вказаний дужками.</br>
</br>
Код нижче викликає синтаксичну помилку:</br>
</br>
let x = 1 && 2 ?? 3; // Синтаксична помилка</br>
Обмеження є досить спірним, воно було додано до специфікації мови з метою уникнення помилок програмування, коли люди почнуть переходити з || до ??.</br>
</br>
Використовуйте явні дужки, щоб працювати з цим оператором:</br>
</br>
let x = (1 && 2) ?? 3; // Працює</br>
</br>
alert(x); // 2</br>
Підсумки</br>
Оператор об’єднання з null ?? надає короткий спосіб вибору першого “визначеного” значення зі списку.</br>
</br>
Він використовується для присвоєння типових значень до змінних:</br>
</br>
// встановлює height=100, якщо height null чи undefined</br>
height = height ?? 100;</br>
Оператор ?? має дуже низький пріоритет – трохи вищий, ніж ? та =, тому розглядайте додавання дужок при використанні його у виразах.</br>
</br>
Цей оператор заборонено використовувати з || або && без явних дужок.</br>


</br>
</p>
</br> &nbsp; &nbsp; &nbsp;


  <br>
  <button onclick="history.back()">ПОВЕРНУТИСЬ</button>

  <script src="script_ObjectJS.js"></script>
  <div class="btn-up btn-up_hide"></div>

  <script>
    const btnUp = {
      el: document.querySelector('.btn-up'),
      show() {
        // удалим у кнопки класс btn-up_hide
        this.el.classList.remove('btn-up_hide');
      },
      hide() {
        // добавим к кнопке класс btn-up_hide
        this.el.classList.add('btn-up_hide');
      },
      addEventListener() {
        // при прокрутке содержимого страницы
        window.addEventListener('scroll', () => {
          // определяем величину прокрутки
          const scrollY = window.scrollY || document.documentElement.scrollTop;
          // если страница прокручена больше чем на 400px, то делаем кнопку видимой, иначе скрываем
          scrollY > 400 ? this.show() : this.hide();
        });
        // при нажатии на кнопку .btn-up
        document.querySelector('.btn-up').onclick = () => {
          // переместим в начало страницы
          window.scrollTo({
            top: 0,
            left: 0,
            behavior: 'smooth'
          });
        }
      }
    }
    btnUp.addEventListener();
    </script>
</body>
</html>