/*
Специфікація має три основні блоки:

describe("title", function() { ... })
Яку функціональність ми описуємо. В нашому випадку, ми описуємо функцію pow. Використовується для групування блоків it, які “виконують роботу”.

it("підносить до n-нного степеня", function() { ... })
У першому аргументі (назві) it ми описуємо людською мовою конкретний спосіб використання функції, а у другому аргументі пишемо функцію, яка тестуватиме цей спосіб.

assert.equal(value1, value2)
Код всередині блоку it має виконуватись без помилок, якщо реалізація правильна.

Функції assert.* використовуються для перевірки того, що функція pow працює, як ми очікуємо. В нашому випадку, ми використовуємо одну з них – assert.equal, вона порівнює аргументи і сповіщає про помилку, якщо вони відрізняються. Тут вона перевіряє, що результат pow(2, 3) дорівнює 8. Є також інші способи порівняння та перевірки, які ми розглянемо пізніше.

*/

describe("pow", function() {

  describe("підносить x до степеня 3", function() {
    before(() => alert("Тестування розпочато – перед усіма тестами")); //виконуються перед/після запуску тестів
    after(() => alert("Тестування завершено – після всіх тестів")); //виконуються перед/після запуску тестів

    beforeEach(() => alert("Перед тестом – початок тесту")); //виконуються перед/після кожного it
    afterEach(() => alert("Після тесту – вихід з тесту")); //виконуються перед/після кожного it

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} піднесене до степеня 3 дорівнює ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  //Щоб вказати на математичну помилку, функції JavaScript зазвичай повертають NaN. Зробимо те ж саме для недійсних значень n.
  describe("pow", function() {

  // ...

  it("для недійсних n результатом є NaN", function() {
    assert.isNaN(pow(2, -1));
  });

  it("для не цілих n результатом є NaN", function() {
    assert.isNaN(pow(2, 1.5));
  });

});

  // ... тут можна додати більше тестів з "describe" та "it"
});

/*Групування проводиться за допомогою вкладеної інструкції describe
Вкладена інструкція describe описує нову “підгрупу” тестів. У вихідних даних ми можемо побачити в заголовку відступи.*/

/*
Ми можемо налаштувати before/after функції, які виконуються перед/після запуску тестів, а також функції beforeEach/afterEach, які виконуються перед/після кожного it.
*/

/* Інші припущення:

Зверніть увагу на припущення assert.isNaN: воно перевіряє на NaN.

Є також інші функції порівняння у Chai, наприклад:

assert.equal(value1, value2) – перевіряє рівність value1 == value2.
assert.strictEqual(value1, value2) – перевіряє сувору рівність value1 === value2.
assert.notEqual, assert.notStrictEqual – зворотня перевірка до вищевказаної.
assert.isTrue(value) – перевіряє, що value === true
assert.isFalse(value) – перевіряє, що value === false
…повний список знаходиться в https://chaijs.com/api/assert/
*/

/*

Підсумки
В BDD спочатку пишуть специфікацію, потім реалізацію. В результаті ми маємо і специфікацію, і код реалізації.

Специфікацію можна використовувати трьома способами:

Як Тести – вони гарантують, що код працює правильно.
Як Документацію – назви describe та it описують, що робить функція.
Як Приклади – тести – це фактично робочі приклади, що показують, як можна використовувати функцію.
За допомогою специфікації ми можемо безпечно вдосконалювати, змінювати, навіть переписувати функцію з нуля і переконатись, що вона досі працює правильно.

Це особливо важливо для великих проєктів, коли функція використовується в багатьох місцях. Коли ми змінюємо таку функцію, просто неможливо вручну перевірити, чи кожне місце, яке її використовує, все ще працює правильно.

Без тестів люди мають два варіанти:

Здійснити зміну, незважаючи ні на що. І тоді наші користувачі зустрічаються з помилками, оскільки ми, мабуть, не перевірили щось вручну.
Або, якщо покарання за помилки суворе, оскільки немає тестів, люди бояться змінювати такі функції, і тоді код застаріває, ніхто не хоче його правити. Це не добре для розробки.
Автоматичне тестування допомагає уникнути цих проблем!

Якщо проєкт покритий тестами, такої проблеми просто немає. Після будь-яких змін ми можемо запустити тести й побачити безліч перевірок, зроблених за лічені секунди.

Крім того, добре перевірений код має кращу архітектуру.

Звісно, це тому, що автоматично перевірений код легше змінювати та вдосконалювати. Але є й інша причина.

Для написання тестів код повинен бути організований таким чином, щоб кожна функція мала чітко описане завдання, чітко визначені вхідні дані та вихідний результат. Це означає хорошу архітектуру з самого початку.

У реальному житті це часом не так просто. Іноді складно написати специфікацію перед фактичним кодом, тому що ще не зрозуміло, як він повинен поводитись. Але в цілому написання тестів робить розробку швидшою і стабільнішою.

Пізніше в підручнику ви зустрінете багато завдань з тестами. Тож ви побачите більше практичних прикладів.

Написання тестів вимагає хороших знань JavaScript. Але ми тільки починаємо це вивчати. Отже, не хвилюйтесь, поки що вам не потрібно писати тести, але ви вже маєте можливість їх прочитати, навіть якщо вони будуть трохи складніші, ніж ті, що наведені у цій главі.
*/

/*   it.only - Mocha запустить лише цей блок  

describe("Підносить x до n-нного степеня", function() {
  it("5 піднесене до степеня 1 дорівнює 5", function() {
    assert.equal(pow(5, 1), 5);
  });

    
  it.only("5 піднесене до степеня 2 дорівнює 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 піднесене до степеня 3 дорівнює 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
*/

/* Приклад:

it("Підносить x до n-нного степеня", function() {
  let x = 5;

  let result = x;
  assert.equal(pow(x, 1), result);

  result *= x;
  assert.equal(pow(x, 2), result);

  result *= x;
  assert.equal(pow(x, 3), result);
});

*/